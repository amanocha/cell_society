#Design Issue
The design issue that I worked on was our implementation of determining the neighbors of cells. We have an abstract class called Update that holds the general methods for updating simulations, and a class for each simulation that extends the Update class in order to update that particular simulation. In the update class, there is a method to determine the immediate neighbors of every cell as well as a method to determine the diagonal neighbors of every cell. Some of the simulations use both, while some of the simulations only use immediate neighbors. While this design works fine when there is only one type of cell shape, this design is not good for multiple cell shapes. Our project has the option of using triangular or hexagonal shapes, and the neighbors are calculated differently for these shapes. We were going to have to create multiple methods for neighbor calculations for each of the different shapes and these would all be populating our Update class. The purpose of the Update class is to update cells and not determine the neighbors of cells, so this design needed to be changed.

#Why the New Version is Better
I created a Neighbors interface that included a method for getting immediate neighbors and a method for getting diagonal neighbors, and had three classes (one for each cell shape: square, triangle, hexagonal) that implement this interface since each cell shape needs these methods. Using an interface creates a "contract" in that the classes that implement the interface have to have the specified methods, and this creates cleaner code and is better design. By creating a Neighbors interface, I could simply have a getNeighbors() method in each extension of Update that calls immediate neighbors and sometimes diagonal neighbors as well, and the cell shape would have already been set in our MetaData class. The appropriate implementation of Neighbors (based on the cell shape) would be called and the Update classes would not have to perform the neighbor calculations; they could simply call either getImmediateNeighbors() and also getDiagonalNeighbors() if the simulation uses it.

#Commits
https://git.cs.duke.edu/CompSci308_2016Fall/cellsociety_team22/commit/9986d4b0e07ae7bf5c0357c1be67834f27ea8a6f
https://git.cs.duke.edu/CompSci308_2016Fall/cellsociety_team22/commit/1827e1bb571671c81305d7d7f923ada5f8a70c8c
#DESIGN 
====

###Introduction
Cellular automata are mathematical models with simple rules that govern the behavior of cells (i.e. replication and destruction). A simulation contains a grids of cells, each of which has a finite number of states and an initial state. As the simulation runs, the state of each cells is updated simultaneously based on the fixed rules and the neighbors of the cells. Rules are applied to each cell based on their current state, but the cells are not actually updated until a second pass through all the cells (when the rules have been applied to every cell). Our team’s objective is to write a Java program that can animate any cellular automata simulation, where the cells have states and rules, and the grid’s size can be determined by a user of the program. There are a variety of sets of rules that can be applied to the cells (i.e. changing color based on the colors of neighbors, moving to different positions) and the starting configuration as well as simulation type are determined by an XML data file. Our design goals involve writing flexible code, and following proper coding conventions and adhering to the coding standards that professionals follow. Our code should be flexible in that new features can easily be added, such as being able to add many different configuration types. In order to have our code be flexible, we will create several classes for each main feature (i.e. Cell, Grid, etc.) that are open in that they can be extended (new variables and methods can be added). New features would extend from these main features and having classes for them will make it easier to implement additions. 

###Overview
The program is divided up into 4 major parts. There are 2 parts that are dedicated to backend (Structures and Engine), one part that is dedicated to XML parsing / creating (XML), and another part that is dedicated to front-end (Animation). There is also the Main class, but that class will just hold the Stage and call the launch() method and the start() method. In the structures package, there will be classes Grid, Cell, and State. In the Engine package, there will be classes Loop and UpdateGrid. In the XML package there will be classes GenerateFile, ParseFile, and Configuration. In the Appearance package there will be classes MainPage, GridScreen, and any labels / button / other front-end classes we will need. 
The main class will call the UI and launch the main menu. The main menu will just be a GUI. Then, the user can parse in an XML file, if they don’t, there will be a standard cellular automata that the program is set to run on that will automatically run. If the user decides to read in the XML file, they can either upload an XML, or they can use the UI to enter in values that they want to customize. In the background this will call both the ReadFile and the CreateFile classes. Once there is information in the system, this information is stored in the Configuration class as a Java object, and from the Configuration class the information is passed around to the relevant classes (mostly be structural classes such as Cell/State/Grid). The Cell structure is the node that will be part of the graph that we are building in the Grid. The State class will be all the different “States” that the cell can be in and we will implement different States through inheritance or composition. The structures will be pretty encapsulated and will receive information from the XML layer, and will pass information to the Engine layer. The Engine is the actual Loop of the animation. It will pass information directly to the appearance layer (or front-end) and that will determine the animation. 
![Model](data/cellsociety_team22_model.png "Our Design Model")

###User Interface
When the program launches we want the UI to open up to a main screen that has multiple options (buttons). One option will take the user to the XML page. The user will then have buttons that provide options to: 1) upload an XML file, which the machine will parse and run (if this information is erroneous, a pop-up will appear, letting the user know that the XML was not accepted for a certain reason), 2) open up a new page that just allows the user to customize the inputs (without ever having to see the XML), where the user can input certain parameters / make the timeline faster / decide which cellular automata they want to see (if the user inputs a number that doesn’t make sense, once again there will be an error message that appears, that doesn’t allow the user to continue), and 3) return to the Main Screen.
Back on the main screen, the second options will start the GameLoop (aka the step in the back-end), and then it will open up to a display of the actual Cellular Automata. This display will be on a screen inside the UI where the user can stop / play / pause the animation. It would also be nice to have a zoom feature, so the audience can decide how they want to view the animation. 
It should also include one or more pictures of the user interface (these pictures can be hand drawn and scanned in, created with a standard drawing program, or screen shots from a dummy program that serves as a exemplar). 

###Design Details 
As mentioned earlier, the program involves layers. To begin with the bottom layer, an XML file is generated in a Generate class that has variables that correspond with the XML file: title, author, parameters (for rules), type, and dimensions. This class takes in information and writes it into an XML file. Once the XML data has been produced (rules are formatted into an XML file), the data is parsed in a Parse class. This class reads the XML file (which is the input) and writes it into the Configuration class. This class essentially holds the data from the XML file as a Java object. It has getter and setter methods that can access the data fields in the XML file so that this information can be used as rules for the simulation.  
There are classes for the main structures in order to make it easier for new features to be added. The Cell class stores information about a cell, such as the current state of the cell, the previous state of a cell, and getter methods to publicly access this information. The information from a cell that is sent to the frontend is what is displayed on the grid. The Grid class stores the information about the position of cells (Cell objects) relative to one another. We will use a graph to store all of the cells in the grid, where each node in the graph is a cell and an edge between two nodes represents that the two nodes are neighbors. Using a graph to store the grid allows flexibility with neighbor and grid types (i.e. if neighbors involves all 8 surrounding cells in a square grid or all surrounding shapes in a grid of shapes). In order to implement the graph, we will use an adjacency matrix, which will make it easy to access the neighbors of an individual cell, which is important for updating the state of a cell. There is additionally a State class which will have extensions for each possible state, such as StateFire (an extension of the State class to determine if a cell is on fire). The State class will determine what type of state(s) is to be used in the simulation by numbering the states and getting information from the Configuration class. If new types of States need to be added, they can easily be done by creating more extended classes from the State class.
Within the Engine package, there is an Update class, which reads information from the Grid class (gets the information about each cell’s neighbors), and updates the properties of cells. This class has methods to move cells, create the new grid (a new grid is drawn with each step of the simulation), and check the neighbors of cells. The Loop class, which contains the loop of the simulation, repeatedly calls the methods from Update in order to continuously create new grids. Within this class there is an initialization method that will draw the initial state of the cells and then in a step method, a new grid is drawn. 
The Animation package involves the frontend classes. There is a Main class that calls the initialization method in the Loop class, which calls the drawGrid method in the Draw class. This method is called each time the step method in the Loop class is called, and is responsible for creating the visual display of the Grid in the UI. The Draw class contains all methods for drawing each cell and their visual properties. The Draw class is not involved with the logic behind the simulation and simply receives information through the Update class. 
In order to apply the rules of a simulation to a cell, whether it is a middle or edge cell, the Grid class will be used to look at the neighbors of a cell, the properties in the Cell class will be updated accordingly, the Update class will call the Grid class to receive the new information, and Loop class will call the method from the Draw class and the update methods in order for the user to see the change. 
    
###Design Considerations
The biggest design issues we had were how to represent the grid, neighbors, and cells. 
At first, we considered using a 2d array to represent the grid because naturally, a grid is thought of as a 2d array. However, we realized that a 2d array would not be flexible when trying to work with a grid that was not aligned in the format of a 2d array. We wanted our grid data structure to be flexible enough that it could support a grid of any shape, which meant that each node could have a variable amount of adjacent nodes. This led us to consider a graph implementation of the grid. With a graph, we could abstract the concept of a grid to vertices and edges, which have no defined number of neighbors or shapes to the vertices. When thinking about the best way to implement the graph, we considered an adjacency matrix and a vertices and edges implementation. The pros of the adjacency matrix included easier traversal and relatively simple implementation. However, the cons were that the matrix would not be very flexible for grid growth and that it may actually be difficult to update the adjacency matrix by keeping track of indices for each node. We chose to make a graph implementation using nodes/vertices and edges because it would be simple to find neighbors of any distance and it is easy to store information within the nodes/vertices, which will probably be a cell object.
Another design consideration was a way to represent neighbors. Originally, we decided to have a neighbors class so that we could keep track of neighbors by modifying the neighbors class to accommodate for different definitions of neighbors. The cons of this are that we would have to figure out a way to generalize neighbors enough so that different simulations would be able to extend different implementations of neighbors. A different solution was to not have a neighbors class and let our game logic deal with computing the neighbors based on the rules. The pros of this were that we could compute neighbors from the graph based on the input configurations and not have to worry about how to represent neighbors differently each time. The con is that, in reality, it may not be so easy to design a method that takes in these input configurations and generates a different list, or representation, of neighbors each time.
Implementing the state of a cell was another design consideration. It was difficult because we realized that states are not binary and will often be any set of descriptors. For example, we could have a set of states such as hot, warm, room temperature, chilled, freezing, or we could have a set of states such as red, blue, yellow, etc. From this we realized that it is difficult to represent a state without knowing the configurations from the XML file. Therefore, we decided to abstract the idea of a state by assigning any type of state a number. After parsing the XML configurations, the state should be able to handle any number of states and assign each state a number. Then, each number could be mapped to the type of state and the rules of the CA could be abstracted to use these numbers instead of the exact state name.

###Team Responsibilities
Our application is split up into 3 main layers and each group member is responsible for the implementation of each of their assigned layers.
Hannah is responsible for all front-end development that deals with JavaFX and the presentation of the game. She has to design how the game looks to the user and figure out how to pass user input to the next “layer”. She will use Aninda’s endpoints to update the game view.
Aninda is responsible for the game logic that lies between the front-end presentation of the game and the back-end classes that Alan will implement. Aninda will deal with the logic involved in updating the application each application loop. Aninda will use the back-end classes to define the game logic and ultimately provide concise, simple endpoints for Hannah to use in updating the user view.
Alan is responsible for creating and parsing the XML files and defining classes for each of the main structures or abstractions of the game. For example, Alan will read from the XML file and map that to a configuration object. From that object, he has to implement a grid class, cell class, state class, and other classes that hold representations of the data that can be used by Aninda to manipulate as the application loops.
Everyone will take secondary responsibility to make sure that their implementations are compatible with the adjacent “layer”. For example, Alan must make sure that his class implementations are what Aninda will be manipulating in working with game logic. Aninda must make sure that she is providing the endpoints that Hannah expects to use when updating the user view.